### Translation and Headline Creation

**Transcript:** Das Erste und Wichtigste: Dies ist kein einfacher TDD-Vortrag

**Translation:** Das Erste und Wichtigste ist, dass dies kein einfacher Vortrag über testgetriebene Entwicklung (TDD) ist und ich werde nicht erklären, wie man TDD richtig macht. Ich erwarte, dass ihr zumindest versteht, dass TDD ein Prozess ist, bei dem wir Tests schreiben, bevor wir den Code schreiben. Es gibt einen Zyklus aus Rot, Grün und Refactoring, bei dem wir einen fehlschlagenden Test schreiben, diesen dann bestehen lassen und anschließend ein neues Refactoring durchführen, um die Qualität unseres Codes zu verbessern. Ihr solltet zumindest so viel wissen. Es spielt keine Rolle, ob ihr derzeit TDD praktiziert, es ist nur wichtig, dass ihr versteht, worum es bei TDD geht und wie es allgemein präsentiert wird.

**Headline:** Kritik an gängigen TDD-Methoden

**Translation:** Ein weiterer Punkt dieses Vortrags ist, dass ich definitiv die oft als vorherrschend angesehenen Ansätze zur testgetriebenen Entwicklung kritisieren werde. Ich werde eine Art von Ansatz kritisieren, der auf Unit-Tests, Mocks und alles andere basiert, sowie auf Gherkin-basierten Syntaxstilen für Akzeptanztests. Wenn ihr euch diesen Methoden zutiefst verpflichtet fühlt und niemand euch jemals überzeugen könnte, dass dies der falsche Weg ist, möchtet ihr vielleicht jemand anderen zum Gespräch suchen, denn genau das werde ich heute versuchen. Und wenn das etwas ist, was ihr nicht hören wollt, dann gibt es keinen Grund für euch, hier zu sein. Wenn ihr jedoch aufgeschlossen seid, werden wir versuchen, verschiedene Vorgehensweisen zu erklären.

**Headline:** TDD und das Missverständnis um Unit-Tests

**Translation:** Okay, das erste und vielleicht bedeutendste Missverständnis über testgetriebene Entwicklung ist, dass es sich bei den Entwicklern um Unit-Tests handelt. Nichts könnte weiter von der Wahrheit entfernt sein. TDD hat absolut nichts mit Unit-Tests zu tun. Wenn ich auf Wikipedia nachsehe, kann ich eine vernünftige Definition von Unit-Testing finden. Wikipedia sagt, dass zur Isolierung von Problemen, die auftreten können, jeder Testfall unabhängig getestet werden sollte. Substituten wie Methoden-Stubs, Mock-Objekte, Fakes und Testharnesses können verwendet werden, um das Testen eines Moduls in Isolation zu unterstützen. Was bedeutet das?

**Headline:** Probleme der Anwendung von klassischem Testen auf TDD

**Translation:** Einst, als wir darüber sprachen, wie wir das Testen automatisieren würden, testeten wir Module. Module sind nebulös definiert; es könnte eine Klasse sein oder viel größer, und die Idee war, dass das Modul als Blackbox behandelt wurde und deine Tests das Modul von außen prüften. Du wolltest sicherstellen, dass alle Fehler, die dein Test aufzeigt, innerhalb der Box waren, also würdest du jegliche Abhängigkeiten dieser Box durch ein Fake oder einen Ersatz ersetzen. Das ist klassisches automatisiertes Testen. Das Problem ist der Versuch, dieses Paradigma auf testgetriebene Entwicklung anzuwenden.

**Headline:** TDD-Praxis und das Missverständnis der Isolation

**Translation:** Was geschah, ist, dass, als die testgetriebene Entwicklung aufkam, einige Leute, die mit automatisierten Tests vertraut waren, annahmen und anderen zu lehren begannen, dass TDD nur automatisiertes Testen sei. Das ist es jedoch nicht. Ein Problem dabei ist der starke Fokus auf Isolation in TDD. Die Idee ist, dass zur Fehlerlokalisierung verstanden werden muss, dass alle Fehler in dieser Komponente und nicht in einem ihrer Mitarbeiter liegen. Daher müssen wir Ersatz verwenden, den wir für alle ihre Mitarbeiter verstehen. Testdoubles sind ein Begriff, den wir verwenden, um diese Dinge zu beschreiben. Die Idee ist wie ein Stuntdouble, etwas, das für den Schauspieler einsteht, den wir nicht der Gefahr aussetzen können.

**Headline:** Der Aufstieg von Mocks in TDD und deren Probleme

**Translation:** Das Ergebnis ist, dass viele Menschen, die von Unit-Tests beeinflusst sind, eine Klasse nehmen, weil sie entscheiden, dass dies das Äquivalent zu einem Modul aus dem automatisierten Software-Engineering-Test ist, und alle ihre Abhängigkeiten durch Ersatz ersetzen. Dies führte schließlich zu einem Denkparadigma in der testgetriebenen Entwicklung, manchmal als bedarfsgetriebene Entwicklung bezeichnet. Diejenigen von euch, die das Buch "Growing Object-Oriented Software, Guided by Tests" gelesen haben, kennen besonders diese Philosophie der bedarfsgetriebenen Entwicklung. Es ist eine Variation des testgetriebenen Entwicklungsprozesses, bei dem der Code von außen nach innen geschrieben wird. Mit anderen Worten, du beginnst effektiv von außen mit der Funktion oder Methode, die du unter Test stellst, und alles davon abhängige wird durch Mock-Objekte ersetzt, die die erwarteten indirekten Ausgaben des geschriebenen Codes überprüfen.

**Headline:** Designfragen und Testgetriebene Entwicklung

**Translation:** Eines der Probleme hierbei ist, dass dies im Allgemeinen ein vorab festgelegtes Design erfordert. Ich muss vielleicht verstehen, vielleicht habe ich Karten verwendet, vielleicht hatte ich eine Tafel, wie ich meinen Domänenraum in Objekte partitioniere, denn ich muss wissen, dass diese Verantwortung nicht das ist, was unter Test steht, es ist die Verantwortlichkeit von etwas anderem, das ich effektiv durch einen Mock oder einen Stunt ersetzen werde. Ich betreibe also ein vorgefertigtes Design, ich lasse nicht zu, dass die Tests mein Design informieren.

**Headline:** Das echte Ziel von TDD und Refactoring

**Translation:** Eine weitere Alternative dazu, die das Buch "Growing Object-Oriented Software, Guided by Tests" tendenziell anbietet, ist, dass du, während du mit deiner Implementierung als Reaktion auf Tests beginnst, erkennst, dass der nächste Teil wahrscheinlich eine andere Klasse sein muss. Die Verantwortung muss übergeben werden, also werde ich jetzt meinen Test für diesen Mock schreiben. Es gibt ein allgemeines Problem damit, dass es unsere Entwicklung stark behindert hat. Im Wesentlichen verstehen wir jetzt in unseren Tests die Implementierungsdetails der Methode oder Klasse, die wir im Grunde testen werden. Wir müssen ihre Details verstehen, weil wir die Interaktionen verstehen müssen, die sie mit Mitarbeitern hat, um ihre Aufgabe zu erfüllen. Wir werden auch in eine Welt gedrängt, in der die meisten dieser Mitarbeiter öffentlich sind, Dinge, die wir sonst testen könnten; sie sind nicht intern oder privat, sie sind nicht verborgen. Bereits 2007, was mich wirklich alt fühlen lässt, schrieb ich dies, weil die TDD-Community zu der Zeit verstand, dass die Leute in die falsche Richtung gingen und wir viel geschrien haben, aber dieses automatisierte Software-Engineering-Spiegel-Paradigma hatte wirklich übernommen.

**Headline:** Die Herausforderungen des Testens mit Mocks

**Translation:** Zurück in den Tagen habe ich gesagt, als ich mich umsah, sah ich viele Leute, die Mocks verwendeten, um all ihre Abhängigkeiten zu ersetzen. Meine Sorge ist, dass sie auf die Probleme stoßen werden, die Mocks mit sich bringen. Gerard Meszaros identifiziert die Probleme hier als zwei spezifische „Gerüche“: über-spezifizierte Software und verhaltenssensitive Software. Typischerweise geschieht dies in stark typisierten Sprachen wie Java oder C#, wo du sagst: „Oh, mein Mitarbeiter, ich muss ihn ersetzen können, ich werde eine Schnittstelle für sie erstellen.“ Anstatt etwas im Konstruktor meiner Klasse aufzubauen, wenn ich Komponenten verwenden möchte, um Verhaltensweisen zu komponieren, anstatt Vererbung zu verwenden, muss ich meine Abhängigkeiten injizieren.

**Headline:** Abhängigkeitsinjektion und ihre Folgen

**Translation:** Früher neigten wir dazu, Dependency Injection für Dinge wie das Strategy Pattern zu verwenden oder effektiv Schichtung zu unterstützen, wo ich effektiv nicht über die konkrete Klasse in einer darüber liegenden Schicht Bescheid wissen konnte. Plötzlich verwendeten wir Schnittstellen, um all unsere Abhängigkeiten zu injizieren, und das Ergebnis war, dass wir diese wirklich langen Ketten von Schnittstellen in unseren Konstruktoren hatten, was bedeutete, dass wir alle anfangen mussten, IoC-Frameworks zu verwenden, um unsere Codebasen zu bauen. Wenn du dich jemals gefragt hast: „Moment mal, meine Klasse scheint dieses Durcheinander von Abhängigkeiten zu sein, ich kann nichts ohne IoC-Frameworks erstellen, ist das die richtige Sache?“, dann ist die Antwort wahrscheinlich nein, wir haben uns selbst in eine Falle gelockt.

**Headline:** Das Problem mit der Verhaltenssensitivität

**Translation:** Was wir unter Verhaltenssensitivität verstehen, ist das Problem, dass wir die Implementierungsdetails unseres Codes ändern können sollten, ohne Tests zu brechen. Tests sollten sich auf den Vertrag konzentrieren, aber tatsächlich fokussieren sich unsere Tests auf die Implementierungsdetails. Allgemein siehst du dieses Verhalten, wenn du versuchst, etwas zu ändern, und dann sagst du: „Ah, ich muss die 300 gebrochenen Tests reparieren, weil ich die Art und Weise geändert habe, wie wir diese Schnittstelle auf dieser anderen Klasse codieren.“ Das sollte nicht passieren. Du änderst ein Implementierungsdetail; das sollte deine Tests nicht brechen und führt auch dazu, dass die Menschen aufhören zu refaktorisieren oder versuchen, Änderungen zu vermeiden, weil es wie „Ja, ich kann das nicht tun, so viele Tests werden brechen, das würde uns Tage kosten, um zu reparieren. Lass uns etwas anderes machen.“ Aber Tests sollten unseren Code flexibler machen, sie sollten das Refactoring ermöglichen. Warum verhindern sie dann das Refactoring?

**Headline:** TDD-Prinzipien und die Bedeutung von Entwicklertests
**Headline:** Die wahre Natur von TDD und die Missverständnisse um „Unit Tests“

**Translation:** Das Prinzip, das ihr verstehen müsst, das seit dem Beginn von TDD besteht, ist, dass Entwickler Entwicklertests schreiben, manchmal auch Programmierertests genannt, nicht Unit-Tests. Es ist erwähnenswert, dass, wenn Kent Beck in „TDD by Example“ über TDD schreibt, Kent nicht der Urheber von TDD ist und das auch zugeben würde. Kent dokumentiert eine Praxis, die er und andere in verschiedenen Softwaregemeinschaften bereits eine Weile genutzt haben, und wenn du „TDD by Example“ liest, findest du Informationen über Mocks, Ausnahmen vom Entwickeln und viele Ideen, von denen die Leute denken, dass sie viel später kamen, die sie aber bereits kannten und verstanden, und das wird dort diskutiert. Er dokumentiert eine Praxis, die Menschen für ein breiteres Publikum nutzen. Kent nennt sie Unit-Tests, aber sie entsprechen nicht sehr gut der akzeptierten Definition von Unit-Tests. Das ist die einzige Referenz zu Unit-Tests im gesamten Buch, du kannst
 das nachschlagen – das ist das einzige Mal, dass es erwähnt wird. Was es bedeutet, ist, dass wir im alltäglichen Gespräch gelegentlich „Unit Tests“ sagen. Als er JUnit entwickelte, bezeichnete er sie als Unit Tests. Es ist eine dieser Arten von milliardenschweren Fehlern, ein bisschen wie das Wort „Micro“ bei Microservices. Die Leute begannen, sich auf einen völlig falschen Ideensatz zu verlegen und brachten Einheiten aus dem automatisierten Software-Engineering ein.

**Headline:** Refactoring und dessen Definition in der TDD-Praxis

**Translation:** Okay, wir können verstehen, was wir besser machen sollten, wenn wir uns das Refactoring ansehen. Dies ist Martin Fowlers Definition von Refactoring: eine Änderung, die an der internen Struktur der Software vorgenommen wird, um sie leichter verständlich und kostengünstiger zu modifizieren, ohne ihr beobachtbares Verhalten zu ändern. Refactoring ist sehr klar definiert. Es gibt beobachtbare Verhaltensweisen, Dinge, von denen andere abhängen, die meine Klasse effektiv tut. Wenn ich ändern möchte, wie sie es tut – ein effizienterer Algorithmus, eine bessere Struktur, effektiv in kleinere Klassen aufgeteilt – sollte ich in der Lage sein, das zu tun, richtig geführt von meinen Tests, um sicherzustellen, dass ich nichts breche.

**Headline:** Die TDD-Zyklen: Rot, Grün, Refaktorieren und deren Missverständnisse

**Translation:** Rot, Grün, Refaktorieren ist der TDD-Zyklus. Refaktorieren ist der letzte Schritt, oft sieht man, dass Leute TDD praktizieren und sagen: „Ja, wir machen viel Rot und Grün, wir refaktorisieren nie wirklich.“ Das ist ein Anzeichen dafür, dass effektiv ein Design im Voraus vorliegt, das du jetzt unter Test bekommen möchtest, denn in der grünen Phase solltest du alles tun, was du kannst, um den Algorithmus zu finden, den du benötigst, um den Test zu bestehen. Du kannst Code von Stack Overflow kopieren, das ist absolut in Ordnung in der grünen Phase. Du kannst ChatGPT bitten, dir zu sagen, wie du den Code schreiben sollst, und ihn einfügen, das ist in der grünen Phase absolut in Ordnung. Du wirst den Code gut machen, sobald er den Test besteht, denn jetzt weißt du genau, welchen Code du brauchst, um den Test zu bestehen, und du kannst dann refaktorieren, um qualitativ hochwertigen Code zu schreiben.

**Headline:** Das Endziel von TDD: Ein Fokus auf Verträge statt Implementierungsdetails

**Translation:** Du kannst verbessern, was ChatGPT dir gegeben hat. Dein Code legt einen Vertrag fest, und was wir wollen, ist, dass du diesen Vertrag testest. Ich kann diesen Vertrag implementieren und dann Tests haben, die sagen, dass ich weiterhin diesen Vertrag erfülle. Aber du solltest in der Lage sein, wie du diesen Vertrag implementierst, zu ändern, ohne irgendwelche deiner Tests zu brechen. Das Problem mit Mocks ist, dass jedes Mal, wenn du versuchst, die Implementierungsdetails zu ändern, du weiterhin deine Tests brichst. Kent Beck sagte irgendwann in den mittleren Zehnerjahren, dass wenn das Verhalten eines Programms aus der Sicht eines Beobachters stabil ist, kein Test geändert werden sollte.

**Headline:** TDD und die Notwendigkeit einer flexiblen Entwicklungsmentalität

**Translation:** Kent Beck hat darauf hingewiesen, dass, wenn das beobachtbare Verhalten eines Programms stabil bleibt, keine Tests geändert werden sollten. Dies unterstreicht die Bedeutung eines tiefgreifenden Verständnisses darüber, was Testgetriebene Entwicklung wirklich ist – es geht nicht nur darum, Fehler zu finden oder Compliance zu bestimmten Praktiken zu zeigen, sondern um eine flexible und anpassbare Herangehensweise bei der Softwareentwicklung. Dies ermöglicht es Entwicklern, Änderungen vorzunehmen, ohne die Kernfunktionalität oder das erwartete Verhalten des Programms zu beeinträchtigen, was zu robusteren und wartungsfreundlicheren Systemen führt.

**Headline:** Schlussfolgerung: TDD ist mehr als nur Testen

**Translation:** Abschließend kann gesagt werden, dass TDD eine Philosophie ist, die über das einfache Testen hinausgeht. Es geht darum, eine Entwicklungsumgebung zu schaffen, in der Verbesserungen und Anpassungen fortlaufend und systematisch integriert werden können, ohne die Integrität des Endprodukts zu gefährden. Durch die Betonung der Wichtigkeit von Refaktorisierung und der Fähigkeit, auf Testergebnisse zu reagieren, ermöglicht TDD den Entwicklern, mit einer grundlegenden Sicherheit zu arbeiten, die kreative Lösungen und innovative Ansätze fördert, während gleichzeitig die Qualität und Zuverlässigkeit der Software gewährleistet bleibt.

### Zusammenfassung des gesamten Textes in Deutsch:

Die obige Diskussion betont, dass testgetriebene Entwicklung (TDD) weit mehr als nur eine Testmethode ist. Es ist ein gründlicher Ansatz, der das Schreiben von Tests vor dem eigentlichen Code vorsieht und darauf abzielt, die Qualität der Softwareentwicklung durch einen zyklischen Prozess von Rot, Grün und Refaktorisieren kontinuierlich zu verbessern. TDD sollte nicht mit herkömmlichen Unit-Tests verwechselt werden, da es sich um eine umfassendere Praxis handelt, die auf die Verbesserung der Codebasis und die Unterstützung einer adaptiven Entwicklungsumgebung abzielt. Wichtig ist, dass TDD die Entwickler dazu ermutigt, Designs durch Tests zu erkunden und zu validieren, anstatt sich auf vordefinierte Designspezifikationen zu verlassen. Dies fördert eine flexible Anpassung an sich ändernde Anforderungen und verbessert die Langzeitwartbarkeit und Robustheit der Software.